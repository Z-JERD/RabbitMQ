参考文档：https://blog.csdn.net/yojhon/article/details/82868860
1. 如何确保消息正确地发送至RabbitMQ？
    发送方确认模式：将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。
                    一旦消息被投递到目的队列后，信道会发送一个确认给生产者（包含消息唯一ID）。
                    如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息
                    发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息

    为什么不用事物功能：
        rabbitmq提供的事务功能，就是生产者发送数据之前开启rabbitmq事务，然后发送消息，如果消息没有成功被rabbitmq接收到，
        那么生产者会收到异常报错，此时就可以回滚事务，然后重试发送消息；如果收到了消息，那么可以提交事务
        但是问题是，rabbitmq事务机制一搞，基本上吞吐量会下来，因为太耗性能。

        事务机制是同步的，你提交一个事务之后会阻塞在那儿
        但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息


2. 如何确保消息接收方消费了消息？
    接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。
                        只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。
    特殊情况：
            1.如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。
            2.如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。

3.如何避免消息重复投递或重复消费？
    在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；
    在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，
    避免同一条消息被重复消费。

4. 消息基于什么传输？
    由于TCP连接的创建和销毁开销较大。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，
    且每条TCP连接上的信道数量没有限制。

5.消息怎么路由？
    消息路由必须有三部分：交换器、路由、绑定
        1.消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。
        2.通过队列路由键，可以把队列绑定到交换器上。
        3.消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进入 “黑洞”。

    常用的交换器主要分为一下三种：
        1.direct：如果路由键完全匹配，消息就被投递到相应的队列
        2.fanout：如果交换器收到消息，将会广播到所有绑定的队列上
        3.topic：可以使来自不同源头的消息能够到达同一个队列

6.如何确保消息不丢失？
    将队列和消息都标记为持久。
    如果消息想要从Rabbit崩溃中恢复，那么消息必须：
        1.在消息发布前，通过把它的 “投递模式” 选项设置为2（持久）来把消息标记成持久化
        2.将消息发送到持久交换器
        3.消息到达持久队列

7.AMQP核心概念：消息队列协议，如图AMQP
        在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，
        这个容器即消息队列。而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则。
        Server：AMQP的服务端称为Broker 接受客户端的链接，实现AMQP实体服务
        Connection：连接，应用程序与Broker的网络连接
        Channel:网络信道，几乎所有的操作都在Channel中进行，它是进行消息读写的通道，客户端可建立多个Channel
                每个Channel代表一个会话任务
        Message：服务器和应用程序之间传送的数据.由Properties和Body组成。Properties对消息进行修饰，比如指定消息的优先级和延迟等特性。
                 Body这是消息的实体内容
        Virtual host：虚拟地址，最上层的消息路由，一个Virtual Host里面可以有若干个Exchange和Queue
                      同一个Virtual Host里面不能有相同名称的Exchange和Queue
                      一般隔离不同的项目和应用。比如订单的项目和优惠券的项目分别放到不同的Virtual Host中
        Exchange：交换机，接受消息，根据路由键转发消息到绑定的Queue
        Binding：Exchange和Queue之间的虚拟连接
        Routing Key：路由规则，确定如何路由一个特定消息
        Queue:消息队列，保存消息并将它们转发给消费者

8.为什么使用AMQP：
         在分布式的系统中，子系统如果使用socket连接进行通讯，有很多问题需要解决。比如：
         1.信息的发送者和接受者如何维持这个连接，如果一方中断，这期间的数据如何防止丢失？
         2.如何降低发送者和接受者的耦合度？
         3.如何让优先级高的接受者先接到数据？
         4.如何将信息发送到相关的接收者，如果接受者订阅了不同的数据，如何正确的分发到接受者？
         5.如何保证接受者接到了完整，正确或是有序的数据？
         AMQP解决了这些问题。RabbitMQ(AMQP)的优点：1.成熟稳定2.路由策略灵活3.消息传输可靠4.集群方案成熟
    AMQP通信流程：
        （1）建立连接Connection。由producer和consumer创建连接，连接到broker的物理节点上。
        （2）建立消息Channel。Channel是建立在Connection之上的，一个Connection可以建立多个Channel。
                producer连接Virtual Host 建立Channel，Consumer连接到相应的queue上建立Channel。
        （3）发送消息。由Producer发送消息到Broker中的exchange中。
        （4）路由转发。exchange收到消息后，根据一定的路由策略，将消息转发到相应的queue中去。
        （5）消息接收。Consumer会监听相应的queue，一旦queue中有可以消费的消息，queue就将消息发送给
                Consumer端。
        （6）消息确认。当Consumer完成某一条消息的处理之后，需要发送一条ACK消息给对应的Queue。
               Queue收到ACK信息后，才会认为消息处理成功，并将消息从Queue中移除；如果在对应的Channel断开后，
               Queue没有收到这条消息的ACK信息，该消息将被发送给另外的Channel。至此一个消息的发送接收流程走完
               了。消息的确认机制提高了通信的可靠性。

 9.消息中间件的对比：https://blog.csdn.net/wqc19920906/article/details/82193316